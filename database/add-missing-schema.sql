-- =====================================================
-- ADD MISSING FLOWORX SCHEMA COMPONENTS
-- Only creates what's missing from existing database
-- =====================================================

-- Enable necessary extensions (if not already enabled)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- =====================================================
-- 1. BUSINESS CONFIGS - Core Dynamic Configuration
-- =====================================================
CREATE TABLE IF NOT EXISTS public.business_configs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  config_json JSONB NOT NULL,
  version INTEGER DEFAULT 1, -- For configuration versioning
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add unique constraint for one active config per user (if not exists)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_business_configs_user_active') THEN
    CREATE UNIQUE INDEX idx_business_configs_user_active ON public.business_configs(user_id) WHERE is_active = true;
  END IF;
END $$;

-- Add indexes for JSONB queries and performance (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_business_configs_user_id') THEN
    CREATE INDEX idx_business_configs_user_id ON public.business_configs(user_id);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_business_configs_active') THEN
    CREATE INDEX idx_business_configs_active ON public.business_configs(is_active) WHERE is_active = true;
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_business_configs_json') THEN
    CREATE INDEX idx_business_configs_json ON public.business_configs USING GIN (config_json);
  END IF;
END $$;

-- =====================================================
-- 2. ONBOARDING PROGRESS - Track User Journey
-- =====================================================
CREATE TABLE IF NOT EXISTS public.onboarding_progress (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  current_step TEXT NOT NULL DEFAULT 'welcome',
  completed_steps TEXT[] DEFAULT '{}',
  step_data JSONB DEFAULT '{}', -- Store data from each step
  google_connected BOOLEAN DEFAULT false,
  workflow_deployed BOOLEAN DEFAULT false,
  onboarding_completed BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- One onboarding record per user
  UNIQUE(user_id)
);

-- Add indexes (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_onboarding_progress_user_id') THEN
    CREATE INDEX idx_onboarding_progress_user_id ON public.onboarding_progress(user_id);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_onboarding_progress_step') THEN
    CREATE INDEX idx_onboarding_progress_step ON public.onboarding_progress(current_step);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_onboarding_progress_completed') THEN
    CREATE INDEX idx_onboarding_progress_completed ON public.onboarding_progress(onboarding_completed);
  END IF;
END $$;

-- =====================================================
-- 3. ANALYTICS & USAGE TRACKING
-- =====================================================
CREATE TABLE IF NOT EXISTS public.user_analytics (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  event_type TEXT NOT NULL, -- 'onboarding_start', 'step_completion', 'workflow_execution', etc.
  event_data JSONB,
  session_id TEXT,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add indexes for analytics queries (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_user_analytics_user_id') THEN
    CREATE INDEX idx_user_analytics_user_id ON public.user_analytics(user_id);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_user_analytics_event_type') THEN
    CREATE INDEX idx_user_analytics_event_type ON public.user_analytics(event_type);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_user_analytics_created_at') THEN
    CREATE INDEX idx_user_analytics_created_at ON public.user_analytics(created_at);
  END IF;
END $$;

-- =====================================================
-- 4. ROW LEVEL SECURITY (RLS) POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE public.credentials ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business_configs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.workflow_deployments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.onboarding_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_analytics ENABLE ROW LEVEL SECURITY;

-- RLS Policies for CREDENTIALS table (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Users can only access their own credentials') THEN
    CREATE POLICY "Users can only access their own credentials" ON public.credentials
      FOR ALL USING (auth.uid() = user_id);
  END IF;
END $$;

-- RLS Policies for BUSINESS_CONFIGS table (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Users can only access their own business configs') THEN
    CREATE POLICY "Users can only access their own business configs" ON public.business_configs
      FOR ALL USING (auth.uid() = user_id);
  END IF;
END $$;

-- RLS Policies for WORKFLOW_DEPLOYMENTS table (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Users can only access their own workflow deployments') THEN
    CREATE POLICY "Users can only access their own workflow deployments" ON public.workflow_deployments
      FOR ALL USING (auth.uid() = user_id);
  END IF;
END $$;

-- RLS Policies for ONBOARDING_PROGRESS table (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Users can only access their own onboarding progress') THEN
    CREATE POLICY "Users can only access their own onboarding progress" ON public.onboarding_progress
      FOR ALL USING (auth.uid() = user_id);
  END IF;
END $$;

-- RLS Policies for USER_ANALYTICS table (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE policyname = 'Users can only access their own analytics') THEN
    CREATE POLICY "Users can only access their own analytics" ON public.user_analytics
      FOR ALL USING (auth.uid() = user_id);
  END IF;
END $$;

-- =====================================================
-- 5. CONFIGURATION VALIDATION FUNCTIONS
-- =====================================================

-- Function to validate business config JSON structure (if not exist)
CREATE OR REPLACE FUNCTION validate_business_config(config_data JSONB)
RETURNS BOOLEAN AS $$
BEGIN
  -- Check required fields exist
  IF NOT (config_data ? 'business_name' AND 
          config_data ? 'contact_email' AND 
          config_data ? 'email_categories' AND 
          config_data ? 'gmail_label_mappings') THEN
    RETURN FALSE;
  END IF;
  
  -- Validate email format
  IF NOT (config_data->>'contact_email' ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$') THEN
    RETURN FALSE;
  END IF;
  
  -- Validate email_categories is an array
  IF NOT (jsonb_typeof(config_data->'email_categories') = 'array') THEN
    RETURN FALSE;
  END IF;
  
  -- Validate gmail_label_mappings is an object
  IF NOT (jsonb_typeof(config_data->'gmail_label_mappings') = 'object') THEN
    RETURN FALSE;
  END IF;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Add constraint to business_configs table (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.check_constraints WHERE constraint_name = 'valid_config_json') THEN
    ALTER TABLE public.business_configs 
    ADD CONSTRAINT valid_config_json 
    CHECK (validate_business_config(config_json));
  END IF;
END $$;

-- =====================================================
-- 6. UTILITY FUNCTIONS FOR n8n INTEGRATION
-- =====================================================

-- Function to get active business config for a user (if not exist)
CREATE OR REPLACE FUNCTION get_user_business_config(p_user_id UUID)
RETURNS JSONB AS $$
DECLARE
  config_data JSONB;
BEGIN
  SELECT config_json INTO config_data
  FROM public.business_configs
  WHERE user_id = p_user_id AND is_active = true
  LIMIT 1;
  
  RETURN COALESCE(config_data, '{}'::JSONB);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get decrypted credentials for a user and service (if not exist)
CREATE OR REPLACE FUNCTION get_user_credentials(p_user_id UUID, p_service_name TEXT)
RETURNS TABLE(
  access_token TEXT,
  refresh_token TEXT,
  expiry_date TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.access_token,
    c.refresh_token,
    c.expiry_date
  FROM public.credentials c
  WHERE c.user_id = p_user_id AND c.service_name = p_service_name;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add triggers to update updated_at columns (if not exist)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.triggers WHERE trigger_name = 'update_business_configs_updated_at') THEN
    CREATE TRIGGER update_business_configs_updated_at 
      BEFORE UPDATE ON public.business_configs 
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.triggers WHERE trigger_name = 'update_onboarding_progress_updated_at') THEN
    CREATE TRIGGER update_onboarding_progress_updated_at 
      BEFORE UPDATE ON public.onboarding_progress 
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;
END $$;
